<?php
/**
 * Created by PhpStorm.
 * User: SuHuayao
 * Date: 2019/10/15
 * Time: 17:04
 */

namespace App\Service\AsyncProcess;

use App\Service\AsyncProcess\Traits\PrivateExposes;

class Process extends \Symfony\Component\Process\Process
{
    use PrivateExposes;

    public $keepLive;

    public $globalId;

    /**
     * AsyncProcess constructor.
     * @param array $command The command to run and its arguments listed as separate entries
     * @param string|null $cwd The working directory or null to use the working dir of the current PHP process
     * @param array|null $env The environment variables or null to use the same environment as the current PHP process
     * @param mixed|null $input The input as stream resource, scalar or \Traversable, or null for no input
     * @param int|float|null $timeout The timeout in seconds or null to disable
     *
     */
    public function __construct($command, string $cwd = null, array $env = null, $input = null, $timeout = 120)
    {
        $this->keepLive = time() + KEEPALIVE;

        //设定私有方法类
        $this->setGlobalPrivateExposesClass(parent::class);

        parent::__construct($command, $cwd, $env, $input, $timeout);

        $this->globalId = "\"$command\"";

    }

    public function refreshLive()
    {
        $this->keepLive = time() + KEEPALIVE;
    }

    public function __destruct()
    {
        //终止定时器
        CheckTimer::delAsyncCheck($this);
        //执行父类destruct
        parent::__destruct(); // TODO: Change the autogenerated stub
    }

    public function waitAsync(callable $outputCallback = null, callable $endCallback = null)
    {
        $this->callPrivateMethod('requireProcessIsStarted', __FUNCTION__);

        $this->updateStatus(false);

        if (null !== $outputCallback) {
            $processPipes = $this->getPrivateVal('processPipes');
            if (!$processPipes->haveReadSupport()) {
                $this->stop(0);
                throw new \LogicException('Pass the callback to the "AsyncProcess::start" method or call enableOutput to use a callback with "AsyncProcess::wait"');
            }

            $this->setPrivateVal('callback', $this->buildCallback($outputCallback));
        }
        //数据读取定时检测
        CheckTimer::addAsyncCheck($this, function ($endCallback) {
            $this->checkTimeout();
            $running = '\\' === \DIRECTORY_SEPARATOR ? $this->isRunning() : $this->getPrivateVal('processPipes')->areOpen();
            if ($running) {
                $this->callPrivateMethod('readPipes', false, '\\' !== \DIRECTORY_SEPARATOR || !$running);
            } else {
                //删除数据读取定时检测
                CheckTimer::delAsyncCheck($this);
                //程序结束检测
                $this->addEndCheck($endCallback);
            }

        }, $endCallback);

    }


    protected function addEndCheck($endCallback)
    {
        //程序结束定时检测
        CheckTimer::addAsyncCheck($this, function ($endCallback) {
            if ($this->isRunning()) {
                $this->checkTimeout();
            } else {
                CheckTimer::delAsyncCheck($this);
                if ($this->getPrivateVal('processInformation')['signaled'] && $this->getPrivateVal('processInformation')['termsig'] !== $this->getPrivateVal('latestSignal')) {
                    throw new \Symfony\Component\Process\Exception\ProcessSignaledException($this);
                }
                call_user_func_array($endCallback, [$this->getPrivateVal('exitcode')]);
            }
        }, $endCallback);
    }

}
